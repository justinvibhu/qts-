{"ast":null,"code":"import * as queryString from 'query-string';\nimport fromEntries from './fromEntries';\nimport validatePathConfig from './validatePathConfig';\nconst getActiveRoute = state => {\n  const route = typeof state.index === 'number' ? state.routes[state.index] : state.routes[state.routes.length - 1];\n  if (route.state) {\n    return getActiveRoute(route.state);\n  }\n  return route;\n};\n/**\n * Utility to serialize a navigation state object to a path string.\n *\n * @example\n * ```js\n * getPathFromState(\n *   {\n *     routes: [\n *       {\n *         name: 'Chat',\n *         params: { author: 'Jane', id: 42 },\n *       },\n *     ],\n *   },\n *   {\n *     screens: {\n *       Chat: {\n *         path: 'chat/:author/:id',\n *         stringify: { author: author => author.toLowerCase() }\n *       }\n *     }\n *   }\n * )\n * ```\n *\n * @param state Navigation state to serialize.\n * @param options Extra options to fine-tune how to serialize the path.\n * @returns Path representing the state, e.g. /foo/bar?count=42.\n */\n\nexport default function getPathFromState(state, options) {\n  if (state == null) {\n    throw Error(\"Got 'undefined' for the navigation state. You must pass a valid state object.\");\n  }\n  if (options) {\n    validatePathConfig(options);\n  } // Create a normalized configs object which will be easier to use\n\n  const configs = options !== null && options !== void 0 && options.screens ? createNormalizedConfigs(options === null || options === void 0 ? void 0 : options.screens) : {};\n  let path = '/';\n  let current = state;\n  const allParams = {};\n  while (current) {\n    let index = typeof current.index === 'number' ? current.index : 0;\n    let route = current.routes[index];\n    let pattern;\n    let focusedParams;\n    let focusedRoute = getActiveRoute(state);\n    let currentOptions = configs; // Keep all the route names that appeared during going deeper in config in case the pattern is resolved to undefined\n\n    let nestedRouteNames = [];\n    let hasNext = true;\n    while (route.name in currentOptions && hasNext) {\n      pattern = currentOptions[route.name].pattern;\n      nestedRouteNames.push(route.name);\n      if (route.params) {\n        var _currentOptions$route;\n        const stringify = (_currentOptions$route = currentOptions[route.name]) === null || _currentOptions$route === void 0 ? void 0 : _currentOptions$route.stringify;\n        const currentParams = fromEntries(Object.entries(route.params).map(_ref => {\n          let [key, value] = _ref;\n          return [key, stringify !== null && stringify !== void 0 && stringify[key] ? stringify[key](value) : String(value)];\n        }));\n        if (pattern) {\n          Object.assign(allParams, currentParams);\n        }\n        if (focusedRoute === route) {\n          var _pattern;\n\n          // If this is the focused route, keep the params for later use\n          // We save it here since it's been stringified already\n          focusedParams = {\n            ...currentParams\n          };\n          (_pattern = pattern) === null || _pattern === void 0 ? void 0 : _pattern.split('/').filter(p => p.startsWith(':')) // eslint-disable-next-line no-loop-func\n          .forEach(p => {\n            const name = getParamName(p); // Remove the params present in the pattern since we'll only use the rest for query string\n\n            if (focusedParams) {\n              // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n              delete focusedParams[name];\n            }\n          });\n        }\n      } // If there is no `screens` property or no nested state, we return pattern\n\n      if (!currentOptions[route.name].screens || route.state === undefined) {\n        hasNext = false;\n      } else {\n        index = typeof route.state.index === 'number' ? route.state.index : route.state.routes.length - 1;\n        const nextRoute = route.state.routes[index];\n        const nestedConfig = currentOptions[route.name].screens; // if there is config for next route name, we go deeper\n\n        if (nestedConfig && nextRoute.name in nestedConfig) {\n          route = nextRoute;\n          currentOptions = nestedConfig;\n        } else {\n          // If not, there is no sense in going deeper in config\n          hasNext = false;\n        }\n      }\n    }\n    if (pattern === undefined) {\n      pattern = nestedRouteNames.join('/');\n    }\n    if (currentOptions[route.name] !== undefined) {\n      path += pattern.split('/').map(p => {\n        const name = getParamName(p); // We don't know what to show for wildcard patterns\n        // Showing the route name seems ok, though whatever we show here will be incorrect\n        // Since the page doesn't actually exist\n\n        if (p === '*') {\n          return route.name;\n        } // If the path has a pattern for a param, put the param in the path\n\n        if (p.startsWith(':')) {\n          const value = allParams[name];\n          if (value === undefined && p.endsWith('?')) {\n            // Optional params without value assigned in route.params should be ignored\n            return '';\n          }\n          return encodeURIComponent(value);\n        }\n        return encodeURIComponent(p);\n      }).join('/');\n    } else {\n      path += encodeURIComponent(route.name);\n    }\n    if (!focusedParams) {\n      focusedParams = focusedRoute.params;\n    }\n    if (route.state) {\n      path += '/';\n    } else if (focusedParams) {\n      for (let param in focusedParams) {\n        if (focusedParams[param] === 'undefined') {\n          // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n          delete focusedParams[param];\n        }\n      }\n      const query = queryString.stringify(focusedParams, {\n        sort: false\n      });\n      if (query) {\n        path += `?${query}`;\n      }\n    }\n    current = route.state;\n  } // Remove multiple as well as trailing slashes\n\n  path = path.replace(/\\/+/g, '/');\n  path = path.length > 1 ? path.replace(/\\/$/, '') : path;\n  return path;\n}\nconst getParamName = pattern => pattern.replace(/^:/, '').replace(/\\?$/, '');\nconst joinPaths = function () {\n  for (var _len = arguments.length, paths = new Array(_len), _key = 0; _key < _len; _key++) {\n    paths[_key] = arguments[_key];\n  }\n  return [].concat(...paths.map(p => p.split('/'))).filter(Boolean).join('/');\n};\nconst createConfigItem = (config, parentPattern) => {\n  var _pattern2;\n  if (typeof config === 'string') {\n    // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern\n    const pattern = parentPattern ? joinPaths(parentPattern, config) : config;\n    return {\n      pattern\n    };\n  } // If an object is specified as the value (e.g. Foo: { ... }),\n  // It can have `path` property and `screens` prop which has nested configs\n\n  let pattern;\n  if (config.exact && config.path === undefined) {\n    throw new Error(\"A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.\");\n  }\n  pattern = config.exact !== true ? joinPaths(parentPattern || '', config.path || '') : config.path || '';\n  const screens = config.screens ? createNormalizedConfigs(config.screens, pattern) : undefined;\n  return {\n    // Normalize pattern to remove any leading, trailing slashes, duplicate slashes etc.\n    pattern: (_pattern2 = pattern) === null || _pattern2 === void 0 ? void 0 : _pattern2.split('/').filter(Boolean).join('/'),\n    stringify: config.stringify,\n    screens\n  };\n};\nconst createNormalizedConfigs = (options, pattern) => fromEntries(Object.entries(options).map(_ref2 => {\n  let [name, c] = _ref2;\n  const result = createConfigItem(c, pattern);\n  return [name, result];\n}));","map":{"version":3,"mappings":"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","names":["queryString","fromEntries","validatePathConfig","getActiveRoute","state","route","index","routes","length","getPathFromState","options","Error","configs","screens","createNormalizedConfigs","path","current","allParams","pattern","focusedParams","focusedRoute","currentOptions","nestedRouteNames","hasNext","name","push","params","stringify","_currentOptions$route","currentParams","Object","entries","map","_ref","key","value","String","assign","split","filter","p","startsWith","forEach","getParamName","undefined","nextRoute","nestedConfig","join","endsWith","encodeURIComponent","param","query","sort","replace","joinPaths","paths","concat","Boolean","createConfigItem","config","parentPattern","exact","_pattern2","_ref2","c","result"],"sources":["C:\\Users\\Admin\\Desktop\\Employee\\node_modules\\@react-navigation\\core\\lib\\module\\getPathFromState.tsx"],"sourcesContent":["import type {\n  NavigationState,\n  PartialState,\n  Route,\n} from '@react-navigation/routers';\nimport * as queryString from 'query-string';\n\nimport fromEntries from './fromEntries';\nimport type { PathConfig, PathConfigMap } from './types';\nimport validatePathConfig from './validatePathConfig';\n\ntype Options<ParamList> = {\n  initialRouteName?: string;\n  screens: PathConfigMap<ParamList>;\n};\n\ntype State = NavigationState | Omit<PartialState<NavigationState>, 'stale'>;\n\ntype StringifyConfig = Record<string, (value: any) => string>;\n\ntype ConfigItem = {\n  pattern?: string;\n  stringify?: StringifyConfig;\n  screens?: Record<string, ConfigItem>;\n};\n\nconst getActiveRoute = (state: State): { name: string; params?: object } => {\n  const route =\n    typeof state.index === 'number'\n      ? state.routes[state.index]\n      : state.routes[state.routes.length - 1];\n\n  if (route.state) {\n    return getActiveRoute(route.state);\n  }\n\n  return route;\n};\n\n/**\n * Utility to serialize a navigation state object to a path string.\n *\n * @example\n * ```js\n * getPathFromState(\n *   {\n *     routes: [\n *       {\n *         name: 'Chat',\n *         params: { author: 'Jane', id: 42 },\n *       },\n *     ],\n *   },\n *   {\n *     screens: {\n *       Chat: {\n *         path: 'chat/:author/:id',\n *         stringify: { author: author => author.toLowerCase() }\n *       }\n *     }\n *   }\n * )\n * ```\n *\n * @param state Navigation state to serialize.\n * @param options Extra options to fine-tune how to serialize the path.\n * @returns Path representing the state, e.g. /foo/bar?count=42.\n */\nexport default function getPathFromState<ParamList extends {}>(\n  state: State,\n  options?: Options<ParamList>\n): string {\n  if (state == null) {\n    throw Error(\n      \"Got 'undefined' for the navigation state. You must pass a valid state object.\"\n    );\n  }\n\n  if (options) {\n    validatePathConfig(options);\n  }\n\n  // Create a normalized configs object which will be easier to use\n  const configs: Record<string, ConfigItem> = options?.screens\n    ? createNormalizedConfigs(options?.screens)\n    : {};\n\n  let path = '/';\n  let current: State | undefined = state;\n\n  const allParams: Record<string, any> = {};\n\n  while (current) {\n    let index = typeof current.index === 'number' ? current.index : 0;\n    let route = current.routes[index] as Route<string> & {\n      state?: State;\n    };\n\n    let pattern: string | undefined;\n\n    let focusedParams: Record<string, any> | undefined;\n    let focusedRoute = getActiveRoute(state);\n    let currentOptions = configs;\n\n    // Keep all the route names that appeared during going deeper in config in case the pattern is resolved to undefined\n    let nestedRouteNames = [];\n\n    let hasNext = true;\n\n    while (route.name in currentOptions && hasNext) {\n      pattern = currentOptions[route.name].pattern;\n\n      nestedRouteNames.push(route.name);\n\n      if (route.params) {\n        const stringify = currentOptions[route.name]?.stringify;\n\n        const currentParams = fromEntries(\n          Object.entries(route.params).map(([key, value]) => [\n            key,\n            stringify?.[key] ? stringify[key](value) : String(value),\n          ])\n        );\n\n        if (pattern) {\n          Object.assign(allParams, currentParams);\n        }\n\n        if (focusedRoute === route) {\n          // If this is the focused route, keep the params for later use\n          // We save it here since it's been stringified already\n          focusedParams = { ...currentParams };\n\n          pattern\n            ?.split('/')\n            .filter((p) => p.startsWith(':'))\n            // eslint-disable-next-line no-loop-func\n            .forEach((p) => {\n              const name = getParamName(p);\n\n              // Remove the params present in the pattern since we'll only use the rest for query string\n              if (focusedParams) {\n                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n                delete focusedParams[name];\n              }\n            });\n        }\n      }\n\n      // If there is no `screens` property or no nested state, we return pattern\n      if (!currentOptions[route.name].screens || route.state === undefined) {\n        hasNext = false;\n      } else {\n        index =\n          typeof route.state.index === 'number'\n            ? route.state.index\n            : route.state.routes.length - 1;\n\n        const nextRoute = route.state.routes[index];\n        const nestedConfig = currentOptions[route.name].screens;\n\n        // if there is config for next route name, we go deeper\n        if (nestedConfig && nextRoute.name in nestedConfig) {\n          route = nextRoute as Route<string> & { state?: State };\n          currentOptions = nestedConfig;\n        } else {\n          // If not, there is no sense in going deeper in config\n          hasNext = false;\n        }\n      }\n    }\n\n    if (pattern === undefined) {\n      pattern = nestedRouteNames.join('/');\n    }\n\n    if (currentOptions[route.name] !== undefined) {\n      path += pattern\n        .split('/')\n        .map((p) => {\n          const name = getParamName(p);\n\n          // We don't know what to show for wildcard patterns\n          // Showing the route name seems ok, though whatever we show here will be incorrect\n          // Since the page doesn't actually exist\n          if (p === '*') {\n            return route.name;\n          }\n\n          // If the path has a pattern for a param, put the param in the path\n          if (p.startsWith(':')) {\n            const value = allParams[name];\n\n            if (value === undefined && p.endsWith('?')) {\n              // Optional params without value assigned in route.params should be ignored\n              return '';\n            }\n\n            return encodeURIComponent(value);\n          }\n\n          return encodeURIComponent(p);\n        })\n        .join('/');\n    } else {\n      path += encodeURIComponent(route.name);\n    }\n\n    if (!focusedParams) {\n      focusedParams = focusedRoute.params;\n    }\n\n    if (route.state) {\n      path += '/';\n    } else if (focusedParams) {\n      for (let param in focusedParams) {\n        if (focusedParams[param] === 'undefined') {\n          // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n          delete focusedParams[param];\n        }\n      }\n\n      const query = queryString.stringify(focusedParams, { sort: false });\n\n      if (query) {\n        path += `?${query}`;\n      }\n    }\n\n    current = route.state;\n  }\n\n  // Remove multiple as well as trailing slashes\n  path = path.replace(/\\/+/g, '/');\n  path = path.length > 1 ? path.replace(/\\/$/, '') : path;\n\n  return path;\n}\n\nconst getParamName = (pattern: string) =>\n  pattern.replace(/^:/, '').replace(/\\?$/, '');\n\nconst joinPaths = (...paths: string[]): string =>\n  ([] as string[])\n    .concat(...paths.map((p) => p.split('/')))\n    .filter(Boolean)\n    .join('/');\n\nconst createConfigItem = (\n  config: PathConfig<object> | string,\n  parentPattern?: string\n): ConfigItem => {\n  if (typeof config === 'string') {\n    // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern\n    const pattern = parentPattern ? joinPaths(parentPattern, config) : config;\n\n    return { pattern };\n  }\n\n  // If an object is specified as the value (e.g. Foo: { ... }),\n  // It can have `path` property and `screens` prop which has nested configs\n  let pattern: string | undefined;\n\n  if (config.exact && config.path === undefined) {\n    throw new Error(\n      \"A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.\"\n    );\n  }\n\n  pattern =\n    config.exact !== true\n      ? joinPaths(parentPattern || '', config.path || '')\n      : config.path || '';\n\n  const screens = config.screens\n    ? createNormalizedConfigs(config.screens, pattern)\n    : undefined;\n\n  return {\n    // Normalize pattern to remove any leading, trailing slashes, duplicate slashes etc.\n    pattern: pattern?.split('/').filter(Boolean).join('/'),\n    stringify: config.stringify,\n    screens,\n  };\n};\n\nconst createNormalizedConfigs = (\n  options: PathConfigMap<object>,\n  pattern?: string\n): Record<string, ConfigItem> =>\n  fromEntries(\n    Object.entries(options).map(([name, c]) => {\n      const result = createConfigItem(c, pattern);\n\n      return [name, result];\n    })\n  );\n"]},"metadata":{},"sourceType":"module"}